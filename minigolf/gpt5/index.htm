
<!DOCTYPE html>
<!-- create a slingshot like mechanic for launching a ball, create a random terrain, inside a hole, if when the ball hits the hall it restarts again, like a golf sling shot game, using js/html, make two walls in the left and right side of screen so the ball can bounce, -->

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Slingshot Golf (GPT 5)</title>
<style>
  :root { color-scheme: light dark; }
  body {
    margin: 0;
    font-family: system-ui, Arial, sans-serif;
    display: grid;
    place-items: center;
    height: 100vh;
    background: linear-gradient(#8fd3ff, #e2f5ff);
  }
  .wrap {
    position: relative;
    user-select: none;
  }
  canvas {
    background: transparent;
    border-radius: 10px;
    box-shadow: 0 15px 40px rgba(0,0,0,.2);
    touch-action: none; /* allow touch drag */
  }
  .ui {
    position: absolute;
    left: 12px;
    top: 12px;
    padding: 8px 10px;
    background: rgba(255,255,255,.7);
    backdrop-filter: blur(4px);
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
  }
  .ui strong { font-weight: 700; }
  .btns {
    position: absolute;
    right: 12px;
    top: 12px;
    display: flex;
    gap: 8px;
  }
  button {
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid rgba(0,0,0,.2);
    background: white;
    cursor: pointer;
    font-size: 12px;
  }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="900" height="540"></canvas>
    <div class="ui">
      <div><strong>Slingshot Golf (GPT 5)</strong></div>
      <div>Drag from the ball and release to launch.</div>
      <div>Bounce off the side walls. Sink it to restart.</div>
      <div>Press R to regenerate terrain.</div>
    </div>
    <div class="btns">
      <button id="resetBtn">Reset (R)</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Physics settings
  const GRAVITY = 0.5;
  const AIR_DRAG = 0.999;
  const WALL_BOUNCE = 0.85;
  const RESTITUTION = 0.55; // ground bounce
  const GROUND_FRICTION = 0.12; // tangential energy loss upon collision
  const BALL_R = 10;

  // Game state
  let heightMap = new Array(W).fill(H - 60);
  let hole = { x: 0, y: 0, r: 22 };
  const ball = { x: 80, y: 0, vx: 0, vy: 0, r: BALL_R };
  let dragging = false;
  let dragStart = { x: 0, y: 0 };
  let dragMouse = { x: 0, y: 0 };
  let lastHoleTime = 0;

  // Utils
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const smoothstep = t => t * t * (3 - 2 * t);
  const rand = (a, b) => a + Math.random() * (b - a);
  const randInt = (a, b) => Math.floor(rand(a, b));

  function heightAt(x) {
    x = Math.floor(clamp(x, 1, W - 2));
    return heightMap[x];
  }

  // Terrain generation: smooth rolling hills + a carved circular hole
  function generateTerrain() {
    const segLen = 110;
    const baseMin = H * 0.55;
    const baseMax = H * 0.75;

    let y0 = rand(baseMin, baseMax);
    let x = 0;

    while (x < W) {
      const xEnd = Math.min(W, x + segLen);
      const y1 = rand(baseMin, baseMax);
      for (let i = x; i < xEnd; i++) {
        const t = smoothstep((i - x) / (xEnd - x));
        // Main smooth interpolation
        let y = lerp(y0, y1, t);
        // Add a bit of small-scale noise
        y += Math.sin(i * 0.04) * 4 + Math.sin(i * 0.013) * 2;
        // Clamp to safe range
        heightMap[i] = clamp(y, H * 0.35, H - 30);
      }
      y0 = y1;
      x = xEnd;
    }

    // Light smoothing pass
    const smoothed = heightMap.slice();
    for (let i = 1; i < W - 1; i++) {
      heightMap[i] = (smoothed[i - 1] + smoothed[i] + smoothed[i + 1]) / 3;
    }

    // Slightly lift at edges to avoid super-low spawn zones
    for (let i = 0; i < 40; i++) {
      const k = 1 - i / 40;
      heightMap[i] = Math.min(heightMap[i], H * 0.72 - k * 40);
      heightMap[W - 1 - i] = Math.min(heightMap[W - 1 - i], H * 0.72 - k * 40);
    }
  }

  function carveHole() {
    const margin = 180;
    hole.x = randInt(margin, W - margin);
    hole.r = randInt(18, 28);
    hole.y = heightAt(hole.x);

    // Carve a circular cavity into the ground (lower half of a circle)
    for (let dx = -hole.r; dx <= hole.r; dx++) {
      const xi = hole.x + dx;
      if (xi < 0 || xi >= W) continue;
      const dy = Math.sqrt(hole.r * hole.r - dx * dx);
      const yCircleLower = hole.y + dy; // lower half: deeper than rim
      if (yCircleLower > heightMap[xi]) {
        heightMap[xi] = yCircleLower;
      }
    }
  }

  function resetLevel() {
    generateTerrain();
    carveHole();
    ball.x = 60;
    ball.y = heightAt(ball.x) - ball.r - 0.5;
    ball.vx = 0;
    ball.vy = 0;
    dragging = false;
  }

  // Physics and collisions
  function updatePhysics() {
    // Gravity + Air drag
    ball.vy += GRAVITY;
    ball.vx *= AIR_DRAG;
    ball.vy *= AIR_DRAG;

    // Integrate
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Left / right walls (visible and collidable)
    if (ball.x - ball.r < 6) {
      ball.x = 6 + ball.r;
      ball.vx = -ball.vx * WALL_BOUNCE;
      ball.vy *= 0.98;
    }
    if (ball.x + ball.r > W - 6) {
      ball.x = W - 6 - ball.r;
      ball.vx = -ball.vx * WALL_BOUNCE;
      ball.vy *= 0.98;
    }

    // Optional ceiling
    if (ball.y - ball.r < 0) {
      ball.y = ball.r;
      ball.vy = -ball.vy * 0.5;
    }

    // Ground collision using height field + surface normal
    const groundY = heightAt(ball.x);
    const overlap = (ball.y + ball.r) - groundY;

    if (overlap > 0) {
      // Surface normal from slope
      const xi = Math.floor(clamp(ball.x, 1, W - 2));
      const dh = heightMap[xi + 1] - heightMap[xi - 1]; // dy over 2px
      let nx = -dh;  // perpendicular to tangent (1, dh)
      let ny = 2;
      const nlen = Math.hypot(nx, ny) || 1;
      nx /= nlen; ny /= nlen;

      // Push the ball out of the ground along normal
      ball.x -= nx * overlap;
      ball.y -= ny * overlap;

      // Decompose velocity into normal/tangential components
      const tx = -ny, ty = nx; // tangent vector (perp to normal)
      let v_n = ball.vx * nx + ball.vy * ny;
      let v_t = ball.vx * tx + ball.vy * ty;

      // Bounce on normal with restitution and threshold to "rest"
      if (Math.abs(v_n) < 0.6) v_n = 0;
      else v_n = -v_n * RESTITUTION;

      // Friction on tangent
      v_t *= (1 - GROUND_FRICTION);

      // Compose back
      ball.vx = nx * v_n + tx * v_t;
      ball.vy = ny * v_n + ty * v_t;

      // Stop jitter when almost still
      if (Math.hypot(ball.vx, ball.vy) < 0.05) {
        ball.vx = 0;
        ball.vy = 0;
      }
    }
  }

  function checkHole() {
    // Consider "sunk" when ball center is deep enough into the circular cavity
    const dx = ball.x - hole.x;
    const dy = ball.y - hole.y;
    const dist2 = dx * dx + dy * dy;

    // At the bottom of cavity, center distance ~ (hole.r - ball.r)
    const target = (hole.r - ball.r * 0.9);
    if (dy >= 0 && dist2 <= target * target) {
      const now = performance.now();
      if (now - lastHoleTime > 400) {
        lastHoleTime = now;
        // Brief pause so it feels responsive, then reset with fresh random terrain
        setTimeout(() => resetLevel(), 150);
      }
    }
  }

  // Rendering
  function drawBackground() {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#aee7ff');
    g.addColorStop(1, '#e6fbff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);
  }

  function drawWalls() {
    ctx.fillStyle = '#8e8e8e';
    ctx.fillRect(0, 0, 6, H);
    ctx.fillRect(W - 6, 0, 6, H);
  }

  function drawTerrain() {
    // Fill terrain below height map
    ctx.beginPath();
    ctx.moveTo(0, H);
    ctx.lineTo(0, heightMap[0]);
    for (let x = 1; x < W; x++) ctx.lineTo(x + 0.5, heightMap[x]);
    ctx.lineTo(W, H);
    ctx.closePath();

    const g = ctx.createLinearGradient(0, H * 0.4, 0, H);
    g.addColorStop(0, '#9edb7b');
    g.addColorStop(1, '#5cae47');
    ctx.fillStyle = g;
    ctx.fill();

    // Draw the hole rim as a subtle darker arc
    ctx.save();
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let dx = -hole.r; dx <= hole.r; dx++) {
      const xi = clamp(hole.x + dx, 0, W - 1);
      const dy = Math.sqrt(Math.max(0, hole.r * hole.r - dx * dx));
      const y = hole.y + dy; // lower half
      if (dx === -hole.r) ctx.moveTo(xi, y);
      else ctx.lineTo(xi, y);
    }
    ctx.stroke();

    // Little flag at the hole
    ctx.strokeStyle = '#7a4e28';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(hole.x, hole.y - 4);
    ctx.lineTo(hole.x, hole.y - 40);
    ctx.stroke();

    ctx.fillStyle = '#d93a3a';
    ctx.beginPath();
    ctx.moveTo(hole.x, hole.y - 40);
    ctx.lineTo(hole.x + 20, hole.y - 35);
    ctx.lineTo(hole.x, hole.y - 30);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawBall() {
    ctx.save();
    // Ball shadow on terrain
    const gy = heightAt(ball.x);
    const shadowY = Math.min(gy - 2, H - 10);
    const h = clamp((ball.y + ball.r) - gy, 0, 50) / 50; // height factor
    ctx.fillStyle = `rgba(0, 0, 0, ${0.25 * (1 - h)})`;
    ctx.beginPath();
    ctx.ellipse(ball.x, shadowY, ball.r * 1.2, ball.r * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ball
    const radial = ctx.createRadialGradient(ball.x - 4, ball.y - 6, 2, ball.x, ball.y, ball.r + 2);
    radial.addColorStop(0, '#ffffff');
    radial.addColorStop(1, '#d0d0d0');
    ctx.fillStyle = radial;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  function drawSlingshot() {
    if (!dragging) return;
    const dx = dragStart.x - dragMouse.x;
    const dy = dragStart.y - dragMouse.y;
    const pow = Math.min(Math.hypot(dx, dy), 140);
    const ax = dragStart.x - (dx === 0 && dy === 0 ? 0 : (dx / Math.hypot(dx, dy)) * pow);
    const ay = dragStart.y - (dx === 0 && dy === 0 ? 0 : (dy / Math.hypot(dx, dy)) * pow);

    ctx.save();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(dragStart.x, dragStart.y);
    ctx.lineTo(ax, ay);
    ctx.stroke();

    ctx.fillStyle = 'rgba(50,50,50,0.15)';
    ctx.beginPath();
    ctx.arc(dragStart.x, dragStart.y, 16, 0, Math.PI * 2);
    ctx.fill();

    // Power indicator
    ctx.fillStyle = '#333';
    ctx.font = '12px system-ui, sans-serif';
    ctx.fillText('Power: ' + Math.round((pow / 140) * 100) + '%', dragStart.x + 12, dragStart.y - 10);
    ctx.restore();
  }

  // Input
  function getMouse(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) * (canvas.width / rect.width),
      y: (evt.clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  canvas.addEventListener('pointerdown', (e) => {
    const m = getMouse(e);
    const dist2 = (m.x - ball.x) * (m.x - ball.x) + (m.y - ball.y) * (m.y - ball.y);
    if (dist2 <= (ball.r + 22) * (ball.r + 22)) {
      dragging = true;
      dragStart.x = ball.x;
      dragStart.y = ball.y;
      dragMouse.x = m.x;
      dragMouse.y = m.y;
      ball.vx = 0;
      ball.vy = 0;
      e.preventDefault();
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const m = getMouse(e);
    dragMouse.x = m.x;
    dragMouse.y = m.y;
  });

  function launch() {
    const dx = dragStart.x - dragMouse.x;
    const dy = dragStart.y - dragMouse.y;
    const powerScale = 0.12;
    const maxSpeed = 22;
    let vx = dx * powerScale;
    let vy = dy * powerScale;
    const speed = Math.hypot(vx, vy);
    if (speed > maxSpeed) {
      const s = maxSpeed / speed;
      vx *= s; vy *= s;
    }
    ball.vx = vx;
    ball.vy = vy;
  }

  canvas.addEventListener('pointerup', () => {
    if (dragging) {
      launch();
      dragging = false;
    }
  });
  canvas.addEventListener('pointercancel', () => {
    if (dragging) {
      dragging = false;
    }
  });

  document.getElementById('resetBtn').addEventListener('click', resetLevel);
  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'r') resetLevel();
  });

  // Main loop
  function tick() {
    // Update
    if (!dragging) updatePhysics();
    else {
      // Keep the ball anchored while aiming
      ball.x = dragStart.x;
      ball.y = dragStart.y;
    }
    checkHole();

    // Draw
    drawBackground();
    drawWalls();
    drawTerrain();
    drawBall();
    drawSlingshot();

    requestAnimationFrame(tick);
  }

  // Start
  resetLevel();
  tick();
})();
</script>
</body>
</html> 