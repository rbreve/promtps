<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Mini Golf â€“ Slingshot</title>
    <style>
      :root {
        color-scheme: dark light;
      }
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #0e1116;
        overscroll-behavior: none;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      .hud {
        position: fixed;
        top: 12px;
        left: 12px;
        padding: 10px 14px;
        background: color-mix(in oklab, #0b1020 85%, #ffffff 0%);
        color: #e8f0ff;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        backdrop-filter: blur(6px);
        font-size: 14px;
        line-height: 1.3;
      }
      .hud strong { font-weight: 700; }
      .hint {
        position: fixed;
        bottom: 14px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 14px;
        background: rgba(255,255,255,0.06);
        color: #dfe8ff;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.25);
        backdrop-filter: blur(6px);
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="hud" id="hud"></div>
    <div class="hint">Drag from the ball to slingshot. Bounce off the walls. Sink it to reset!</div>

    <script>
      // High-level configuration and constants
      const CONFIG = {
        gravityPixelsPerSecond2: 2200,
        airDrag: 0.0005, // fractional per ms
        wallRestitution: 0.9,
        groundRestitution: 0.46,
        groundFriction: 0.92, // tangential velocity multiplier on each collision
        ballRadius: 12,
        maxLaunchPower: 1200, // pixels per second
        launchPowerScale: 3.4, // pixels of drag -> velocity
        restSpeedThreshold: 25, // px/s considered "at rest"
        holeRadius: 18,
        holeCatchSpeed: 900, // if below this and within radius, count as sunk
      };

      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const hud = document.getElementById('hud');

      // Game state
      let width = 0;
      let height = 0;
      let heightMap = new Float32Array(0); // ground y for each integer x
      let hole = { x: 0, y: 0, r: CONFIG.holeRadius };
      let levelIndex = 1;
      let strokesInLevel = 0;

      const ball = {
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        r: CONFIG.ballRadius,
        color: '#f6f7fb',
        canShoot: true,
      };

      // Input state for slingshot
      let isDragging = false;
      let dragStart = { x: 0, y: 0 };
      let dragNow = { x: 0, y: 0 };

      // Utilities
      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function length(x, y) {
        return Math.hypot(x, y);
      }

      function normalize(x, y) {
        const d = Math.hypot(x, y) || 1;
        return { x: x / d, y: y / d };
      }

      function lerp(a, b, t) { return a + (b - a) * t; }

      // Terrain generation: smooth 1D noise using layered sines
      function regenerateTerrain() {
        heightMap = new Float32Array(Math.max(1, Math.floor(width)));

        const baseY = height * 0.72; // baseline ground
        // Random parameters for three sine layers
        const layers = Array.from({ length: 3 }, (_, i) => {
          const wavelength = (width * (0.8 - i * 0.22)) * (0.9 + Math.random() * 0.2);
          const amplitude = (height * (0.10 - i * 0.03)) * (0.8 + Math.random() * 0.4);
          const phase = Math.random() * Math.PI * 2;
          return { wavelength, amplitude, phase };
        });

        for (let x = 0; x < heightMap.length; x++) {
          let y = baseY;
          for (const l of layers) {
            y += l.amplitude * Math.sin((x / l.wavelength) * Math.PI * 2 + l.phase);
          }
          // Soft clamp to keep ground on-screen
          y = clamp(y, height * 0.38, height * 0.9);
          heightMap[x] = y;
        }

        // Smooth the height map with a small moving average
        const smooth = new Float32Array(heightMap.length);
        const windowSize = 5;
        for (let x = 0; x < heightMap.length; x++) {
          let sum = 0;
          let count = 0;
          for (let k = -windowSize; k <= windowSize; k++) {
            const xi = clamp(x + k, 0, heightMap.length - 1);
            sum += heightMap[xi];
            count++;
          }
          smooth[x] = sum / count;
        }
        heightMap = smooth;

        // Place a hole somewhere on the back half
        const hx = Math.floor(lerp(width * 0.62, width * 0.9, Math.random()));
        hole.x = clamp(hx, 40, width - 40);
        hole.y = heightMap[Math.floor(hole.x)] - 4; // slightly above the ground path
        hole.r = CONFIG.holeRadius;

        // Put the ball near the front-left, on the ground
        placeBallAtStart();
      }

      function placeBallAtStart() {
        const startX = Math.floor(lerp(40, 120, Math.random()));
        ball.x = clamp(startX, ball.r + 2, width - ball.r - 2);
        ball.y = getGroundY(ball.x) - ball.r - 1;
        ball.vx = 0; ball.vy = 0;
        ball.canShoot = true;
      }

      function getGroundY(xFloat) {
        if (heightMap.length === 0) return height * 0.75;
        const xi = clamp(Math.floor(xFloat), 0, heightMap.length - 1);
        const xi2 = clamp(xi + 1, 0, heightMap.length - 1);
        const t = clamp(xFloat - xi, 0, 1);
        return lerp(heightMap[xi], heightMap[xi2], t);
      }

      function getGroundSlope(xFloat) {
        // Central difference derivative for local slope (dy/dx)
        const x = clamp(Math.floor(xFloat), 1, heightMap.length - 2);
        const dy = heightMap[x + 1] - heightMap[x - 1];
        const dx = 2;
        return dy / dx;
      }

      function resizeCanvas() {
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        width = Math.floor(window.innerWidth);
        height = Math.floor(window.innerHeight);
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        regenerateTerrain();
      }

      function resetLevelAndRandomize() {
        levelIndex += 1;
        strokesInLevel = 0;
        regenerateTerrain();
      }

      // Input handling (mouse + touch)
      function isOverBall(px, py) {
        return Math.hypot(px - ball.x, py - ball.y) <= ball.r + 18;
      }

      function onPointerDown(px, py) {
        if (!ball.canShoot || !isOverBall(px, py)) return;
        isDragging = true;
        dragStart.x = px; dragStart.y = py;
        dragNow.x = px; dragNow.y = py;
      }

      function onPointerMove(px, py) {
        if (!isDragging) return;
        dragNow.x = px; dragNow.y = py;
      }

      function onPointerUp(px, py) {
        if (!isDragging) return;
        isDragging = false;
        if (!ball.canShoot) return;

        // Launch velocity opposite of drag vector
        const dx = dragStart.x - dragNow.x;
        const dy = dragStart.y - dragNow.y;
        let vx = dx * CONFIG.launchPowerScale;
        let vy = dy * CONFIG.launchPowerScale;
        // Clamp to max power
        const spd = length(vx, vy);
        if (spd > CONFIG.maxLaunchPower) {
          const u = normalize(vx, vy);
          vx = u.x * CONFIG.maxLaunchPower;
          vy = u.y * CONFIG.maxLaunchPower;
        }

        ball.vx = vx;
        ball.vy = vy;
        ball.canShoot = false;
        strokesInLevel += 1;
      }

      // Mouse events
      canvas.addEventListener('mousedown', (e) => {
        onPointerDown(e.offsetX, e.offsetY);
      });
      canvas.addEventListener('mousemove', (e) => {
        onPointerMove(e.offsetX, e.offsetY);
      });
      window.addEventListener('mouseup', (e) => {
        onPointerUp(e.offsetX, e.offsetY);
      });

      // Touch events
      canvas.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        onPointerDown(t.clientX - rect.left, t.clientY - rect.top);
      }, { passive: false });
      canvas.addEventListener('touchmove', (e) => {
        const t = e.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        onPointerMove(t.clientX - rect.left, t.clientY - rect.top);
      }, { passive: false });
      canvas.addEventListener('touchend', (e) => {
        const t = e.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        onPointerUp(t.clientX - rect.left, t.clientY - rect.top);
      }, { passive: false });

      // Physics & update
      let lastTime = performance.now();
      function update() {
        const now = performance.now();
        const dtMs = now - lastTime;
        lastTime = now;
        const dt = Math.min(32, dtMs) / 1000; // clamp delta for stability

        // Apply gravity & air drag
        if (!ball.canShoot || isDragging) {
          const drag = Math.exp(-CONFIG.airDrag * dtMs);
          ball.vx *= drag;
          ball.vy = ball.vy * drag + CONFIG.gravityPixelsPerSecond2 * dt;
        }

        // Integrate
        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // Left/Right wall collisions
        if (ball.x - ball.r < 0) {
          ball.x = ball.r;
          ball.vx = Math.abs(ball.vx) * CONFIG.wallRestitution;
        }
        if (ball.x + ball.r > width) {
          ball.x = width - ball.r;
          ball.vx = -Math.abs(ball.vx) * CONFIG.wallRestitution;
        }

        // Ground collision against terrain
        const groundY = getGroundY(ball.x);
        if (ball.y + ball.r > groundY) {
          // Compute surface normal from slope
          const slope = getGroundSlope(ball.x);
          const n = normalize(-slope, 1);

          // Push ball out of terrain along normal
          const penetration = ball.y + ball.r - groundY;
          ball.x -= n.x * penetration;
          ball.y -= n.y * penetration;

          // Reflect velocity on normal
          const vDotN = ball.vx * n.x + ball.vy * n.y;
          if (vDotN > 0) {
            ball.vx -= (1 + CONFIG.groundRestitution) * vDotN * n.x;
            ball.vy -= (1 + CONFIG.groundRestitution) * vDotN * n.y;
          }

          // Apply friction along tangent
          const t = { x: n.y, y: -n.x };
          const vDotT = ball.vx * t.x + ball.vy * t.y;
          ball.vx -= vDotT * (1 - CONFIG.groundFriction) * t.x;
          ball.vy -= vDotT * (1 - CONFIG.groundFriction) * t.y;

          // Snap tiny speeds to zero and allow re-shoot
          const speed = Math.hypot(ball.vx, ball.vy);
          if (speed < CONFIG.restSpeedThreshold) {
            ball.vx = 0; ball.vy = 0; ball.canShoot = true;
          }
        }

        // Hole detection: if center within radius and not going too fast
        const holeDx = ball.x - hole.x;
        const holeDy = ball.y - (hole.y + 5); // center slightly below ground top
        const distToHole = Math.hypot(holeDx, holeDy);
        const speedNow = Math.hypot(ball.vx, ball.vy);
        if (distToHole < hole.r && speedNow < CONFIG.holeCatchSpeed) {
          // Simple sink behavior: animate briefly then reset
          ball.vx *= 0.6; ball.vy *= 0.6;
          setTimeout(() => { resetLevelAndRandomize(); }, 220);
        }

        draw();
        requestAnimationFrame(update);
      }

      // Rendering
      function drawBackground() {
        const grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, '#0b1224');
        grad.addColorStop(1, '#0a0d17');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);
      }

      function drawWalls() {
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(3, 0); ctx.lineTo(3, height);
        ctx.moveTo(width - 3, 0); ctx.lineTo(width - 3, height);
        ctx.stroke();
        ctx.restore();
      }

      function drawTerrain() {
        if (heightMap.length === 0) return;

        // Fill terrain
        ctx.save();
        const landGrad = ctx.createLinearGradient(0, height * 0.4, 0, height);
        landGrad.addColorStop(0, '#1e2a18');
        landGrad.addColorStop(1, '#0e140c');
        ctx.fillStyle = landGrad;
        ctx.beginPath();
        ctx.moveTo(0, height);
        ctx.lineTo(0, heightMap[0]);
        for (let x = 1; x < heightMap.length; x++) {
          ctx.lineTo(x, heightMap[x]);
        }
        ctx.lineTo(width, height);
        ctx.closePath();
        ctx.fill();

        // Draw the hole (cup)
        // Top rim shadow
        ctx.fillStyle = '#0a0a0a';
        ctx.beginPath();
        ctx.ellipse(hole.x, hole.y + 5, hole.r, hole.r * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Rim highlight
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(hole.x, hole.y + 3, hole.r * 0.9, hole.r * 0.45, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Flag
        ctx.strokeStyle = '#304bff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(hole.x, hole.y - 48);
        ctx.lineTo(hole.x, hole.y + 2);
        ctx.stroke();
        ctx.fillStyle = '#ff4557';
        ctx.beginPath();
        ctx.moveTo(hole.x, hole.y - 48);
        ctx.lineTo(hole.x + 26, hole.y - 40);
        ctx.lineTo(hole.x, hole.y - 32);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }

      function drawBall() {
        ctx.save();
        const r = ball.r;
        const grad = ctx.createRadialGradient(ball.x - r * 0.5, ball.y - r * 0.8, r * 0.3, ball.x, ball.y, r * 1.2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#c9d2ff');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawSlingshot() {
        if (!isDragging) return;

        const dx = dragStart.x - dragNow.x;
        const dy = dragStart.y - dragNow.y;
        const power = Math.min(CONFIG.maxLaunchPower, length(dx * CONFIG.launchPowerScale, dy * CONFIG.launchPowerScale));
        const u = normalize(dx, dy);

        // Rubber band
        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(dragNow.x, dragNow.y);
        ctx.stroke();

        // Power indicator arrow
        const arrowLength = Math.min(150, power * 0.12);
        const ax2 = ball.x + u.x * arrowLength;
        const ay2 = ball.y + u.y * arrowLength;
        ctx.lineWidth = 6;
        ctx.strokeStyle = 'rgba(64,128,255,0.85)';
        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(ax2, ay2);
        ctx.stroke();

        // Arrow head
        const headSize = 10;
        const left = { x: ax2 - u.x * headSize + -u.y * headSize * 0.6, y: ay2 - u.y * headSize + u.x * headSize * 0.6 };
        const right = { x: ax2 - u.x * headSize + u.y * headSize * 0.6, y: ay2 - u.y * headSize + -u.x * headSize * 0.6 };
        ctx.fillStyle = 'rgba(64,128,255,0.85)';
        ctx.beginPath();
        ctx.moveTo(ax2, ay2);
        ctx.lineTo(left.x, left.y);
        ctx.lineTo(right.x, right.y);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }

      function drawHud() {
        hud.innerHTML = `
          <div><strong>Level:</strong> ${levelIndex}</div>
          <div><strong>Strokes:</strong> ${strokesInLevel}</div>
          <div><strong>Status:</strong> ${ball.canShoot ? 'Aim & drag' : 'In motion'}</div>
        `;
      }

      function draw() {
        drawBackground();
        drawWalls();
        drawTerrain();
        drawBall();
        drawSlingshot();
        drawHud();
      }

      // Initialize
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      requestAnimationFrame(update);
    </script>
  </body>
</html>


